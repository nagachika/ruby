YARV の finish 命令を削除して VM のループを抜けるのを leave 命令で行なうように
しています。コミットログにかなり詳細に背景と変更理由が書かれていますのでそれを
読めばだいたいわかると思います。
なのでちょっと前提となる知識を書くと、YARV の VM 処理というのは ISeq
(Instruction Sequence)と呼んでいる命令列を順に(もちろん分岐やメソッド呼び出しは
ある)実行する大きなループになっています((まあ実際にはコンパイラがサポートしてい
たらシンプルなループではなくて、各命令後に次の命令の処理のアドレスまで直接ジャ
ンプするようなことをしてたりもしますが)。Ruby のメソッドの呼び出しはこのループ
の中に閉じていて、VMのスタックフレーム(マシンスタックとは別物)を積んだり降ろし
たりはしますが C の関数レベルでは同じ関数の中ぐるぐるループを回っていることにな
ります。
そこから C で書かれたメソッドを呼びだすと、当然ながら C の関数を呼びます。でそ
こからさらに Ruby で書かれたメソッド(とかブロックとか)を呼ぶと、新たに VM ルー
プを実行する関数を呼んでネストした VM 処理が走りはじめます。で最後のスタックフ
レームを取り除く(つまり呼び出された Ruby のメソッドから抜ける時)はこの VM ルー
プ自体から抜けて、その関数から return しないといけません。その仕組みとしてこれ
までは Ruby の処理を開始する時にかならずスタックフレームの底に finish という命
令だけを含むフレームを積んでおいて、これが実行されると VM のループから抜けると
いう処理にしていました。
このコミットではこの finish 命令を廃止して、leave(メソッドなどから返る、スタッ
クフレームを取り除く命令)でループを止めることができるようにフレームのフラグに
VM_FRAME_FLAG_FINISH というのを追加しています。そもそも finish を導入したのには
leave でこのようにフラグをチェックすると分岐が入るのでパフォーマンスが悪くなる
というのを気にしていたようですが、最近の CPU の分岐予測能力は高いのであまり気に
しなくていいのかもしれないというのと、finish を使うとフレームを常に1つ余分に使
うのとスタック操作が入ることになるのでそんなにパフォーマンス面でも有利ではない
かもしれないというので方針変更することにしたようです。
