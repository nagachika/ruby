lambda 型の Proc オブジェクトをブロックとしてメソッドに渡した時に、その lambda
内の return の扱いについて仕様変更しています。 [ruby-core:56193] [Feature #
8693]
込み入った話なので順に書きます。このチケットの議論を追ってなかったので過去の知
見からの推測が入ってるので間違ってるかもしれません。ご指摘お願いします。
まず Proc オブジェクトには lambda{} や ->{} で作成した時には lambda フラグとい
うのが立って、Proc.new で作成した Proc オブジェクトや通常のブロックをブロック引
数として受け取った時のものとは少し挙動が変化します。
 1. ブロックパラメータの arity チェックがある(引数の数が一致しないと
    ArgumentError が発生したりする)
 2. return 文が break 相当になる(通常は return はそのメソッドを抜けるのですが、
    lambda のブロックを抜けるようになる)
2つ目の仕様は lambda{} をいわゆる無名関数っぽく書けるようにするために追加(変更)
された仕様だったのだと思います。
ところがこの return の挙動は、lambda{} や ->{} で生成した Proc オブジェクトをさ
らに m(&b) のように & つきの記法でブロックとしてメソッドに渡し、さらに渡された
ブロックが yield で起動された時にだけ無効になるという微妙な挙動を示していました
。
def m1_yield
  p(yield)
end
def m2
  m1_yield(&lambda{ return :block })
  :m2
end
m2
# => :block
m1_yield がブロックを yield で呼び出しているので、渡しているのが lambda による
Proc オブジェクトなのにかかわらずその中の return が lambda から抜けるのではなく
て、 m2 メソッドから抜けています。
なおブロックの呼び出しを yield ではなくブロック引数として受け取って Proc#call
メソッドで呼ぶと lambda としての動作が保存されます。
def m1_call(&b)
  p(b.call)
end
def m2
  m1_call(&lambda{ return :block })
  :m2
end
m2
:block  # <- m1_call 内の p(b.call) が実行されるので :block が表示される
# => :m2
しかしこれだとメソッド内でどのようにブロックを起動しているかに依存して渡す
lambda の挙動が変化するという使いずらい仕様だったので、yield で起動した時もブロ
ックが lambda 由来の Proc オブジェクトだった場合は return が lambda から抜ける
(つまりブロックから帰ってくる)という挙動に揃えられています。 [ruby-core:56193]
[Feature #8693]
[DEL:ついでにこの変更で lambda の1つ目の特徴である引数の arity チェックの厳格化
も引き継ぐようになったみたいです。つまり上の例で m1_yield で yield 1 で呼び出し
てしまうとか、m2 で渡す lambda のブロックパラメータが1以上だったりする
ArgumentError が発生します。こっちはこっちで微妙なところですねー…。:DEL]
[追記]ArgumentError については勘違いで、この変更の前から元々 ArgumentError が発
生するようになっていたようです。なので今回変更されたのは lambda の 2. の特徴に
ついてのみみたいです。[/追記]
