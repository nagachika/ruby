require でライブラリをロードする時に同じファイルを同時に読まないようにファイル
パス単位のロックが存在するのですが、ロード後の load_unlock() の処理でテーブルか
らファイルパスに対応する Barrier オブジェクトを削除してしまっていたので、同じフ
ァイルをロードしようと待っている別の Thread があった場合にロックが漏れているタ
イミングがあったのを修正しています。かなり複雑な条件ですね。 [ruby-core:41618]
[Bug #5754]
ところで rb_barrier_waiting(barrier) で待っている Thread がいた時に
rb_barrier_destroy() を呼んでしまっていいんでしょうか？ Barrier から Mutex への
参照を切ってしまうので後続の Thread の Barrier の操作ができなくなりそうな気がす
るのですが。
[2011-12-14 追記] Barrier の使われかたを勘違いしていました。正常終了の開放時に
destroy するのは Barrier の通常の使いかたです。rb_barrier_release() をみて大丈
夫かなと思ってたのですが、destroy したらそもそも後続の待たされている Thread は
Barrier の取得に失敗するので release をしないはずです。[/追記]
