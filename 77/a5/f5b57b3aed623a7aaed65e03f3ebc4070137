やはり callcc で at_exit のブロック内の継続を、その後に実行される at_exit のブ
ロック内で呼び出して戻ると free(3) 済みの領域を再度 free() してしまってエラーに
なっていたのを修正しています。 at_exit で登録する終了時の処理を実行してすぐに解
放していたのを最後にまとめて解放するようにしています。
いやーしかしこれは他にもいろいろ同じような問題があって大変そうですね。 Fiber が
あれば callcc はもういらないんじゃ…。 [ruby-core:58329] [Bug #9110]
