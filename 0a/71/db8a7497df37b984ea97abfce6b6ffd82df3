VM のスタックフレームの構造の変更が行われています。
コミットログにかなり詳しく書かれています。 YARV のスタックフレームの構造として
、VM のスタック(マシンスタックとは別もの)にローカル変数(メソッドやクラス/モジュ
ール定義ごとの変数スコープ)とブロック変数のための領域を指すためのポインタをそれ
ぞれ(lfp と dfp)持っていて、ローカル変数/ブロック変数はそこからのインデックス(
オフセット)でアクセスしています。この lfp と dfp は通常のメソッドの中では同じ位
置を指していて、ブロックの中に入ると lfp は外側のローカル変数(そのブロックが置
かれているメソッドやらクラス/モジュールの定義やトップレベル)の領域を指していて
、dfp は今いるブロックのブロック変数のスコープを指していて異なるという状態にな
ります。またブロックはネストできるので、dfp は dfp[0] を辿ることで順に外側のブ
ロック変数の領域を指して、最後に lfp と同じ位置を指すようになるという構造をして
いました。この構造はささださんが図にしたものがあってこれをみると比較的わかりや
すいと思うのですが、どこかに公開されているものはないでしょうか……。
このコミットでは、 lfp と dfp をフレーム情報に両方持っていたものを、ep という1
つのポインタにまとめてしまって、ep は dfp と同様にブロック内ではブロック変数の
領域を指し、ep[0] を辿っていくことで lfp に相当するローカル変数の領域に辿りつけ
るので、これを LEP(local EP) と呼んで、LEP を判定するマクロ、取得するマクロを導
入しています。
あとはデバッグ用に型(enum の導入などがあります)。
define_method にブロックを渡して定義したメソッドの場合の lfp と dfp がややこし
くて定数の探索とか? 微妙な問題があったような気がするので(dfp を辿っていっても
lfp に辿りつかないとか? 確かそんなことがあったような気がする)これで良くなるかと
言うと、このコミット自体は不要だった2つのポインタを1つにまとめる変更をしただけ
で基本的な構造には変化はないと思うのでそのあたりは今後のささだ先生の活躍に期待
です。
