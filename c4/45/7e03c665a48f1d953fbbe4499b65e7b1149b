CI_SET_FASTPATH() という関数マクロを導入して、vm_call_method() で一度呼び出した
らメソッドの種別に応じて rb_call_info_t::call の関数ポインタに関数をセットして
、 YARV の命令(send, invokesuper など)から直接対象の関数を呼び出すことで、呼び
出し情報のセットや vm_call_general() -> vm_call_method() -> 対象の関数とディス
パッチする手間をスキップしています。ただし protected のメソッドの時は call をセ
ットしないようにしています。protected だと vm_call_method() で呼び出せるかどう
かのチェックをしているのでそこをスキップできないということだと思うのですが、
private も同じあたりでチェックしているのになぜ protected だけ特別扱いなんでしょ
うか……。[追記]これは考えてみたら private の時も一度は vm_call_method() のチェ
ックは通るわけで、private のチェックは呼ばれかた(FCALL つまり関数的な、レシーバ
を省略した呼びかた)だけで決まるので、一度チェックすれば同じ結果を使いまわせるの
でスキップして良いのでした[/追記]
また vm_call_ivar()、vm_call_attrset() から rb_check_arity() により引数の数のチ
ェックを削っていますが[DEL:、これは VM_CALLEE_SETUP_ARG() で引数の数をチェック
する処理が入っているため不要になったものだろうと思います。:DEL]というのは見落し
ていて、vm_call_method() で CI_SET_FASTPATH() で call をセットするところで呼ぶ
ようにしていました。
この最適化は experimental なので何か問題があったら教えてね、ということなので、
是非最新版で手元のアプリケーションをテストしてみて、おかしな現象があったら報告
してみましょう。
