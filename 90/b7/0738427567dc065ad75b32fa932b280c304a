Symbol GC を導入しています。 Ruby では Symbol は内部的に一意な ID という型の数
値が与えられてオブジェクトとは別のテーブルで(も)管理されていたため GC の対象に
ならず、大量の Symbol を生成するとメモリ使用量が増えたまま不要になっても減らな
いという問題が知られていましたが、String#to_sym などで Ruby のメソッドで生成し
た Symbol は GC できるようになるようです。
インタプリタが最初から作っている Symbol や C の関数で生成したもの、また SYM2ID
() で ID 値が取り出されて C level でその値が格納された(可能性がある)ものは
pindown といって GC されないようにしています(Symbol オブジェクトの参照がなくな
っても ID が利用されている可能性があるので)が、それ以外の Symbol は参照がなくな
ったら GC されるようにしています。このために struct RSymbol という構造体とオブ
ジェクト型の T_SYMBOL が追加されています。 GC 可能な Symbol は struct RVALUE の
スロットに入るようになるんですね(あたりまえですけど)。 GC されると同じ Symbol
でも object_id が別の値になりますが、まあそれはいいだろうってことですね。
また pin down された Symbol は global_symbols.pinned_dsym に登録されて、ここか
らマークされることで GC されなくなるんですね。てことはスロットは占有したままに
なるので SYM2ID() で pin down してしまうことはできるだけ避けるようにしたほうが
いいんですね。
[ruby-core:61456] [Feature #9634]
