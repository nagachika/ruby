拡張ライブラリ zlib で Zlib::Inflate.inflate() などでデータによって例外
Zlib::BufError が発生してしまっていた不具合を修正しています。チケットにも書きま
したが、zstream_run_func() で inflate() (や deflate()) を繰り返し呼ぶところで、
入力用のバッファが空になるのと同時に出力用のバッファの空きもちょうど 0 になると
もう一度 inflate() が呼ばれるのですが、入力バッファが空の状態で呼ばれると
Z_BUF_ERROR が返され、これがそのまま例外になってしまいます。 Z_BUF_ERROR はバッ
ファの容量不足を知らせるための返り値で、これが返ってきたら出力用バッファを伸長
して再度呼び出すようになっているのですが、出力用バッファに余りがある状態で
Z_BUF_ERROR が返ってくることを想定していないためです。 z->stream.avail_in (入力
用バッファの残りサイズ)が 0 だったらループを抜けるようにすればいいかと思ったの
ですが、そうすると deflate() の時にテストが失敗してしましました。どうやら
deflate() の時は z->stream.state の opaque な構造体に別のバッファがあり、
avail_in が 0 でも実はこっそり入力が残っている場合があるので avail_out > 0 の状
態で返ってくるまで deflate() を呼ばないといけないのでした。なので呼び出す関数が
inflate() の時だけ avail_in == 0 で break するようにしています。
[ruby-dev:46149] [Bug #7040]
