[ruby-core:42672] で報告されている nokogiri を使った時の GC で解放済みの領域が
mark される問題の対応として、マーク用の bitmap をクリアする
gc_clear_mark_on_sweep_slots() を削除してそのかわりに rest_sweep() でマーク済み
の slot を全て sweep 処理するようにしています。
詳しく現象を確認していないので推測ですが、参照関係のあるオブジェクトのうち一方
は回収済みでもう一方が false pointer でマークされてしまい、そこ経由で回収済みの
オブジェクトにさわろうとしてしまっていたということでしょうか? この場合だと参照
しているほうがちゃんと子をマークしていないのがいけないような気もします。
