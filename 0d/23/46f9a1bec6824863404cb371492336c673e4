ブロック引数 (&blk) のような記法で受け取ったブロックを blk.call のように Proc#
call メソッドで呼び出した時に、Proc オブジェクト化を避けて yield と同等の
vm_invoke_block() を利用するようにしています。 r60397 で導入された Proc オブジ
ェクト化の遅延の効果が最終的に blk.call のように呼び出された時もなくならないよ
うにしているのだと思います。2.5 のブロック引数の Proc オブジェクト化遅延は最終
的にブロック呼び出しを blk.call みたいにすると結局 Proc オブジェクト化されるの
で、高速化のためには block_given? や yield を使わないといけなかったのですが、
blk.call を使っても高速なままにできるという、待ち望まれていた最適化だと思います
。
call メソッド呼び出しの最適化処理(vm_call_opt_call())で rb_vm_invoke_proc() で
はなく vm_invoke_block() を呼ぶようにしているのがミソで、この時 call->receiver
に通常の Proc オブジェクトが入ってればそれが呼ばれて、遅延されてるブロック引数
だったら cfp から渡されているブロックの呼び出しになるようにしているのだと思いま
す。
